(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{457:function(e,t,s){"use strict";s.r(t);var r=s(29),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"rust-sgx-sdk-v1-1-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-1-3"}},[e._v("#")]),e._v(" Rust SGX SDK v1.1.3")]),e._v(" "),s("p",[s("strong",[e._v("Supports Intel SGX SDK v2.12")])]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust nightly-2020-10-25")])]),e._v(" "),s("p",[s("strong",[e._v("Docker images")]),e._v(" We provide docker images: 1604-1.1.3/1804-1.1.3/2004-1.1.3/fedora31-1.1.3/centos8-1.1.3")]),e._v(" "),s("p",[s("strong",[e._v("Please upgrade asap")]),e._v(" Intel fixed couple of bugs in 2.12. Please upgrade as\nsoon as possible!")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-1-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-1-2"}},[e._v("#")]),e._v(" Rust SGX SDK v1.1.2")]),e._v(" "),s("p",[s("strong",[e._v("Supports Intel SGX SDK v2.9.1")])]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust nightly-2020-04-07")])]),e._v(" "),s("p",[s("strong",[e._v("Docker images")]),e._v(" We provide docker images: 1604-1.1.2/1804-1.1.2/2004-1.1.2/fedora27-1.1.2. CentOS support is unfinished. Contribution is welcome!")]),e._v(" "),s("p",[s("strong",[e._v("sgx_signal")]),e._v(" enables signal handling. It'll be pretty handy when debugging with "),s("code",[e._v("ud2")]),e._v(" or "),s("code",[e._v("SIGILL")]),e._v(" events! Please look at "),s("a",{attrs:{href:"samplecode/unit-test/enclave/src/test_signal.rs"}},[e._v("signal sample")]),e._v(" for usage.")]),e._v(" "),s("p",[s("strong",[e._v("Removed sgx_core_futures")]),e._v(" since Rust supports "),s("code",[e._v("async")]),e._v("/"),s("code",[e._v("await")]),e._v(" in "),s("code",[e._v("no_std")]),e._v(" environment.")]),e._v(" "),s("p",[s("strong",[e._v("Bug fixes")])]),e._v(" "),s("p",[s("strong",[e._v("Removed compiler-rt patch")])]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-1-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-1-1"}},[e._v("#")]),e._v(" Rust SGX SDK v1.1.1")]),e._v(" "),s("p",[s("strong",[e._v("Supports Intel SGX SDK v2.9")])]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust nightly-2020-03-12")])]),e._v(" "),s("p",[s("strong",[e._v("Docker images refactored")]),e._v(" Due to the requirement of LVI mitigation, the docker image has to contain very new version of GCC/G++ and GNU binutils with LVI patch. We shipped our docker images with two options: (1) build gcc from source, or (2) use gcc from well-known repo. Please use at your own choice.")]),e._v(" "),s("p",[s("strong",[e._v("New proc macro "),s("code",[e._v("sgx_align")])]),e._v(" "),s("code",[e._v("sgx_align")]),e._v(" can help with mitigate INTEL-SA-00219. Please refer to the "),s("a",{attrs:{href:"samplecode/unit-test/enclave/src/test_alignstruct.rs"}},[e._v("unit test codes")]),e._v(" for sample usage.")]),e._v(" "),s("p",[s("strong",[e._v("Use hashbrown to replace old std::collections")]),e._v(" We move to hashbrown v0.7 and skipped v0.6.")]),e._v(" "),s("p",[s("strong",[e._v("sgx_core_futures")]),e._v(" provides basic future primitive. We'll provide some samples later.")]),e._v(" "),s("p",[s("strong",[e._v("sgx_crypto_helper")]),e._v(" is working on both trusted/untrusted side now.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-1-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-1-0"}},[e._v("#")]),e._v(" Rust SGX SDK v1.1.0")]),e._v(" "),s("p",[s("strong",[e._v("Supports Intel SGX SDK v2.7.1")])]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust nightly-2019-11-25")])]),e._v(" "),s("p",[s("strong",[e._v("Fedora 27 supported")]),e._v(" Added dockerfile for Fedora 27.")]),e._v(" "),s("p",[s("strong",[e._v("Threading and synchronization")]),e._v(" We implemented "),s("code",[e._v("thread::spawn")]),e._v(" and ported "),s("code",[e._v("std::sync::mpsc")]),e._v(". Please look into unittest for usage.")]),e._v(" "),s("p",[s("strong",[s("code",[e._v("is_x86_feature_detected")])]),e._v(" We found a global feature indicator "),s("a",{attrs:{href:"https://github.com/apache/teaclave-sgx-sdk/wiki/%60is_x86_feature_detected%60-in-Rust-SGX-SDK",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("g_cpu_feature_indicator")])]),e._v(" and enabled "),s("code",[e._v("is_x86_feature_detected")]),e._v(" without triggering "),s("code",[e._v("cpuid")]),e._v(" instruction.")]),e._v(" "),s("p",[s("strong",[e._v("New aligned allocator primitives and data structures")]),e._v(" To mitigate "),s("a",{attrs:{href:"https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00219.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Intel-SA-00219")]),e._v(", we provided "),s("code",[e._v("AlignBox<T>")]),e._v(" for dynamic allocation, and aligned key types such as "),s("code",[e._v("sgx_align_key_256bit_t")]),e._v(", "),s("code",[e._v("sgx_align_key_128bit_t")]),e._v(" for static allocation. To help understand this vulnerability, please look into the wiki article "),s("a",{attrs:{href:"https://github.com/apache/teaclave-sgx-sdk/wiki/Mitigation-of-Intel-SA-00219-in-Rust-SGX",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mitigation of Intel SA 00219 in Rust SGX")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("Link flag change")]),e._v(" In this version, "),s("code",[e._v("-lsgx_tcxx")]),e._v(" must be placed before "),s("code",[e._v("-lsgx_tstdc")]),e._v(". We've changed all "),s("code",[e._v("Makefile")]),e._v("s.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-9-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-9-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.9 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust nightly-2019-08-01")]),e._v(" in master branch (rustc 1.38.0). Stable branch would be pushed later.")]),e._v(" "),s("p",[s("strong",[e._v("Supports Intel SGX SDK v2.6")])]),e._v(" "),s("p",[s("strong",[e._v("CentOS 7.6 supported")]),e._v(" Added dockerfile for CentOS 7.6.")]),e._v(" "),s("p",[s("strong",[e._v("New sgx crates")]),e._v(" sgx_backtrace, sgx_backtrace_sys, sgx_demangle, sgx_panic_abort, sgx_panic_unwind.")]),e._v(" "),s("p",[s("strong",[e._v("Removed libbacktrace and new libunwind is in sgx_unwind")])]),e._v(" "),s("p",[s("strong",[e._v("No longer requires libsgx_tcxx")]),e._v(" unless the enclave depends on protected_fs or tse.")]),e._v(" "),s("p",[s("strong",[e._v("Removed all local third_party crates")]),e._v(" We forked everything and maintain them by merge bot. We'll merge the commits periodically, and provide a world map of the forked crates very soon.")]),e._v(" "),s("p",[s("strong",[e._v("Upgrade Notes")]),e._v(" Please update your edl files as well as the common headers. And please adjust the Xargo.toml if your project are using xargo.")]),e._v(" "),s("p",[s("strong",[e._v("The Apache Incubator")]),e._v(" Rust SGX SDK would be soon transferred to the Apache Incubator, as a subproject of MesaTEE. It'll be in a repo like "),s("code",[e._v("apache/incubator-rust-sgx-sdk")]),e._v(", while the former link "),s("code",[e._v("baidu/rust-sgx-sdk")]),e._v(" still works well.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-8-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-8-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.8 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust nightly-2019-05-22")]),e._v(" in master branch (rustc 1.36.0)")]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust stable-2019-05-14")]),e._v(" in stable branch (rustc 1.34.2)")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("Bug fix in sgx_alloc. Correct the MIN_ALIGN to 8 bytes according to Intel's memory alloctor.")])]),e._v(" "),s("li",[s("p",[e._v("Bug fix in sgx_tstd/panicking.rs. Now master branch can output panic strings correctly.")])]),e._v(" "),s("li",[s("p",[e._v("Fix "),s("code",[e._v("eprintln!")]),e._v(" support in sgx_tstd.")])]),e._v(" "),s("li",[s("p",[e._v("New code sample: kvdb-memdb and its dependencies. Thanks to @bradyjoestar !")])]),e._v(" "),s("li",[s("p",[e._v("Fixed all Makefiles. Put only "),s("code",[e._v("sgx_trts")]),e._v(' in the "whole" linking group.')])]),e._v(" "),s("li",[s("p",[e._v('Fixed xargo sysroots and remove unused "ghost" crates under "xargo" directory. Now there is no duplicated SDK crates in the project.')])]),e._v(" "),s("li",[s("p",[e._v("Deprecated "),s("code",[e._v("sgx_tstd::Error::type_id")]),e._v(" function. See Rust issue 60784.")])]),e._v(" "),s("li",[s("p",[e._v("sgx_tunittest is edition now! Thanks to @elichai!")])]),e._v(" "),s("li",[s("p",[e._v("add "),s("code",[e._v("fn source")]),e._v(" in sgx_tstd::error::Error")])]),e._v(" "),s("li",[s("p",[e._v("Fix env var bugs in sgx_libc, sgx_urts, and sgx_ustdc.")])]),e._v(" "),s("li",[s("p",[e._v("sgx_cov leverages lcov to generate code coverage report for SGX enclave. Please refer to sgx-cov code sample for details.")])])]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-7-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-7-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.7 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Supports Intel SGX SDK v2.5")])]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust nightly-2019-04-26")]),e._v(" in master branch (rustc 1.36.0)")]),e._v(" "),s("p",[s("strong",[e._v("Supports Rust stable-2019-04-25")]),e._v(" in stable branch (rustc 1.34.1)")]),e._v(" "),s("p",[s("strong",[e._v("Refactored "),s("code",[e._v("sgx_tstd")]),e._v(" to support mio")])]),e._v(" "),s("p",[s("strong",[e._v("New sample code mio")]),e._v(" shows how to use ported version of mio in SGX enclave.")]),e._v(" "),s("p",[s("strong",[e._v("sgx_tunittest gives more information on return and supports closures")]),e._v(" Thanks to @elichai!")]),e._v(" "),s("p",[s("strong",[e._v("sgx_crypto_helper can export public key now")]),e._v(" Please refer to static-data-distribution for usages.")]),e._v(" "),s("p",[s("strong",[e._v("sgx_tcrypto_helper can be directly used for enclave")]),e._v(" Thanks to @brenzi and @electronix!")]),e._v(" "),s("p",[s("strong",[e._v("sealeddata sample supports "),s("code",[e._v("T")]),e._v(" and "),s("code",[e._v("[T]")]),e._v(" and serialized data structures")]),e._v(" Thanks to @matthias-g!")]),e._v(" "),s("p",[s("strong",[s("code",[e._v("quote_type")]),e._v(" is configurable now in all Rust-based remote attestation sample codes")]),e._v(" Thanks to @bradyjoestar!")]),e._v(" "),s("p",[s("strong",[e._v("New sample code tr-mpc")]),e._v(" Thanks to @bradyjoestar!")]),e._v(" "),s("p",[s("strong",[e._v("New sample code: Go and Java ue-ra client")]),e._v(" Thanks to @bradyjoestar!")]),e._v(" "),s("p",[s("strong",[e._v("New sample code sgxcounter")]),e._v(" shows how to use Monotonic Counter in SGX.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-6-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-6-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.6 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Add proper support to memalign in sgx_alloc")]),e._v(" Thanks to @cbeck88.")]),e._v(" "),s("p",[s("strong",[e._v("Use "),s("code",[e._v("core::mem::zeroed")]),e._v(" to get a zero-initialized struct")]),e._v(" Thanks to @cbeck88.")]),e._v(" "),s("p",[s("strong",[e._v("Fix ucd-generate lazy_static dep")]),e._v(" Thanks to @nhynes.")]),e._v(" "),s("p",[s("strong",[e._v("Added support for closures in sgx_tunittest")]),e._v(" Thanks to @elichai.")]),e._v(" "),s("p",[s("strong",[e._v("Added rust-base58")]),e._v(" Thanks to @brenzi.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-5-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-5-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.5 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Upgrade Recommended")]),e._v(" Intel issued a security advisory "),s("a",{attrs:{href:"https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00202.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("INTEL-SA-00202")]),e._v(" and fixed the problem in Intel SGX SDK v2.4.")]),e._v(" "),s("p",[s("strong",[e._v("Support Intel SGX SDK v2.4")]),e._v(". We add a "),s("a",{attrs:{href:"https://github.com/intel/linux-sgx/pull/359",target:"_blank",rel:"noopener noreferrer"}},[e._v("patch")]),e._v(" to Intel SGX SDK to fix aesm signature verification error.")]),e._v(" "),s("p",[s("strong",[e._v("Support Rust nightly-2019-01-28")]),e._v(" in master branch (rustc 1.34.0).")]),e._v(" "),s("p",[s("strong",[e._v("Support Rust stable-2019-01-17")]),e._v(" in stable branch (rustc 1.32.0).")]),e._v(" "),s("p",[s("strong",[e._v("Removed dependency of "),s("code",[e._v("posix_memalign")])]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("Refactored dockerfiles")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("New sgx_libc crate")]),e._v(" is isolated from "),s("code",[e._v("sgx_trts::libc")]),e._v(". It provides a bunch of extra ocalls in this release.")]),e._v(" "),s("p",[s("strong",[e._v("Renamed vendor name from unknown to mesalock")]),e._v(" in every target json file.")]),e._v(" "),s("p",[s("strong",[e._v("Refactored sgx_trts")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("The net2 crate")]),e._v(" is ported into SGX enclave. Now one can create a socket or start listening on a port in SGX enclave (with built-in ocalls).")]),e._v(" "),s("p",[s("strong",[e._v("Mesalink support")]),e._v(" Now one can establish a remote attestation based TLS connection to enclave using "),s("a",{attrs:{href:"https://github.com/mesalock-linux/mesalink",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mesalink")]),e._v(". A working example is "),s("a",{attrs:{href:"https://github.com/mesalock-linux/mesalink/tree/master/examples/sgx_uera_client",target:"_blank",rel:"noopener noreferrer"}},[e._v("here")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("New sgx_ucrypto crate")]),e._v(" enables using Intel SGX style crypto primitives in untrusted app.")]),e._v(" "),s("p",[s("strong",[e._v("New sgx_crypto_helper")]),e._v(" helps serialize/deserialize RSA keypair in either untrusted app or SGX enclave.")]),e._v(" "),s("p",[s("strong",[e._v("New code sample: hello-regex")]),e._v(" shows how to use regex in SGX enclave.")]),e._v(" "),s("p",[s("strong",[e._v("New code sample: static_data_distribution")]),e._v(" shows how to use sgx_crypto_helper to statically distribute secrets to SGX enclave with dynamic RSA key provisioning.")]),e._v(" "),s("p",[s("strong",[e._v("New code sample: net2")]),e._v(" shows how to create a socket/listen on a port using net2 crate.")]),e._v(" "),s("p",[s("strong",[e._v("New code sample: pcl")]),e._v(" shows how to use Intel's Protected Code Loader to encrypt an enclave binary and launch the encrypted binary.")]),e._v(" "),s("p",[s("strong",[e._v("Upgrade serde-rs")]),e._v(" to 1.0.84.")]),e._v(" "),s("p",[s("strong",[e._v("New third-party libraries ported")]),e._v(" regex, aho-corasick, fst, memchr, memmap-rs, thread_local, ucd-generate, utf8-ranges, version_check.")]),e._v(" "),s("p",[s("strong",[e._v("Known issue")]),e._v(" remoteattestation sample is not working in 18.04 because it depends on old log4cpp v1.0. Please use ue-ra or mutual-ra instead.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-4-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-4-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.4 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Upgrade recommended")]),e._v(" Rust community has fixed a "),s("a",{attrs:{href:"https://blog.rust-lang.org/2018/09/21/Security-advisory-for-std.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("memory bug")]),e._v(" in "),s("a",{attrs:{href:"https://github.com/rust-lang/rust/commit/8ac88d375e00c91a3db5d78852048322f88be3c1",target:"_blank",rel:"noopener noreferrer"}},[e._v("liballoc")]),e._v(" recently. We strongly recommend to upgrade to rust-sgx-sdk v1.0.4 and use the most recent Rust releases to build it.")]),e._v(" "),s("p",[s("strong",[e._v("Support Intel SGX SDK v2.3.1")]),e._v(" We skip Intel SDK v2.3 due to a "),s("a",{attrs:{href:"https://github.com/intel/linux-sgx/pull/313",target:"_blank",rel:"noopener noreferrer"}},[e._v("logic error patched in 2.3.1")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("Support Rust nightly-2018-10-01")]),e._v(" in master branch")]),e._v(" "),s("p",[s("strong",[e._v("Support Rust stable-2018-09-25")]),e._v(" in stable branch")]),e._v(" "),s("p",[s("strong",[e._v("New third party libraries")]),e._v(" bit-vec, chrono, erased-serde, fxhash, nan-preserving-float, num-bigint, quick-error, raft-rs, time, webpki-roots, yasna")]),e._v(" "),s("p",[s("strong",[e._v("mutual-ra code sample")]),e._v(" contains an implementation of remote attestation based TLS channel between enclaves. The algorithm comes from Intel's "),s("a",{attrs:{href:"https://github.com/cloud-security-research/sgx-ra-tls/blob/master/whitepaper.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("paper")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("ue-ra code sample")]),e._v(" contains an implementation of remote attestation based TLS channel between untrusted party and enclave, use the same algorithm above.")]),e._v(" "),s("p",[s("strong",[e._v("switchless code sample")]),e._v(" shows how to use the new "),s("strong",[e._v("Switchless")]),e._v(" model provided by Intel.")]),e._v(" "),s("p",[s("strong",[e._v("Refactored dockerfile")]),e._v(" Since Intel has provided support to Ubuntu 18.04, we could remove the experimental docker image. Now we provide docker images for ubuntu 16.04 and 18.04 with both Rust nightly and stable releases.")]),e._v(" "),s("p",[s("strong",[e._v("AI Model serialize/deserialize in rusty-machine")]),e._v(" Resolved in "),s("a",{attrs:{href:"https://github.com/baidu/rust-sgx-sdk/issues/35",target:"_blank",rel:"noopener noreferrer"}},[e._v("issue 35")]),e._v(". One can serialize a rusty-machine model into a json string and deserialize from it.")]),e._v(" "),s("p",[s("strong",[e._v("Third party crates upgraded/discontinued")]),e._v(" Upgraded ring/webpki/rustls, wasmi/wabt-rs-core. Removed lazy-static, parity-wasm and untrusted because these crates supports "),s("code",[e._v("no_std")]),e._v(" and could be used directly from crates.io.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-1-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-1-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.1 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Support Intel SGX SDK v2.2")])]),e._v(" "),s("p",[s("strong",[e._v("Support Rust nightly-2018-07-16")])]),e._v(" "),s("p",[s("strong",[e._v("Support Rust stable-2018-07-10")])]),e._v(" "),s("p",[s("strong",[e._v("New third party libraries")]),e._v(" bytes, http, iovec, rust-crypto, rust-fnv and rust-threshold-secret-sharing.")]),e._v(" "),s("p",[s("strong",[e._v("New code sample")]),e._v(" Thanks to @davidp94 for the secretsharing code sample.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v1-0-0-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v1-0-0-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v1.0.0 Release Notes")]),e._v(" "),s("p",[e._v("Baidu X-Lab provides Rust SGX SDK that is a bundle of basic libraries, scripts and ported libraries for developing Intel SGX programs in Rust programming language. Based on this SDK, developers could easily build up their SGX programs in Rust. Rust SGX SDK provides the strongest defence and helps protect the secret data reside in an enclave effectively even when the OS is compromised. It is important to real world data privacy and cloud security. Since the first day of open source, we have recevied many recommendations and supports from both academic and industry. Today, we are proudly releasing the 1.0.0 version of Rust SGX SDK, indicating that Rust SGX SDK is becoming stable and ready for production.")]),e._v(" "),s("p",[e._v("Intel SGX is being well adopted by industry, such as Microsoft, Ali cloud and IBM, which indicates that SGX's ability for trusted computing and data protection has been accepted by giant companies and the software stack of Intel SGX is becoming more and more critical. Ideally, the SGX application should guarantee safety from the first line of its code, instead of consumpting tremenduous of engineer-months for code auditing and fuzzing. Thus, C/C++ is not the first choice of programming language for Intel SGX applications due to the lack of memory safety guarantees. To this end, we proposed "),s("strong",[e._v("Rust SGX SDK")]),e._v(" which brings the best practice of memory safety to SGX projects, and reduces the workload of developing flawless SGX projects significantly. Based on this, we can leverage new techniques such as "),s("a",{attrs:{href:"documents/nbsp.pdf"}},[s("strong",[e._v("Non-bypassable Security Paradigm")])]),e._v(" to assist the formal verification of critical security attributes on large projects, which is believed to be the state-of-art of practical application security guarantee. Apart from the C/C++ SDK provided by Intel, Rust SGX SDK is the only recommended SDK listed on Intel SGX's "),s("a",{attrs:{href:"https://software.intel.com/en-us/sgx",target:"_blank",rel:"noopener noreferrer"}},[e._v("homepage")]),e._v(".")]),e._v(" "),s("p",[e._v("From v1.0.0, Rust SGX SDK is heading towards stability and production. As a proof of concept, we provide a solution to the classic Private-Set-Intersection problem. PSI is a cryptographic technique that allows two parties to compute the intersection of their sets without revealing anything except the intersection. The PSI solution is very useful in many cases such as threat intelligence exchanging and sharing. In this proof of concept, we build a fair, trusted, reliable and attestable arbiter which can compute the intersection set with almost zero overhead and guarantee safety and security. In addition, the PSI algorithm is side channel resistant.")]),e._v(" "),s("p",[e._v("What's more, we provide a set of ported in-enclave WebAssembly interpreter and code samples. The support of WebAssembly (wasm) in Rust SGX SDK is an experimental feature in this version. As the hottest target platform, WebAssembly has been supported by major programming languages and compilers. Microsoft, Google, Apple and Mozilla support WebAssembly in their browser's Javascript engines. LLVM, Rust and Go provide experimental wasm as target platform and Parity has released v1.10 recently to support "),s("a",{attrs:{href:"https://paritytech.io/parity-1-10-opportunity-released/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Wasm Smart Contracts")]),e._v(". With the help of SGX WebAssembly interpreter, executing programs written in major programming languages and smart contract is within a stone's throw.")]),e._v(" "),s("p",[e._v("Good news! Rust SGX SDK proposal has been adopted by "),s("a",{attrs:{href:"https://paris.rustfest.eu/schedule/",target:"_blank",rel:"noopener noreferrer"}},[e._v("RustFest'18")]),e._v(" and we'll present this work in Paris this week!")]),e._v(" "),s("p",[s("strong",[e._v("WebAssembly interpreter")]),e._v(" We port the Parity's "),s("a",{attrs:{href:"https://github.com/paritytech/wasmi",target:"_blank",rel:"noopener noreferrer"}},[e._v("wasmi")]),e._v(" to Intel SGX (see ported third party libraries at "),s("a",{attrs:{href:"third_party/parity-wasm"}},[e._v("parity-wasm")]),e._v("/"),s("a",{attrs:{href:"third_party/wabt-rs-core"}},[e._v("wabt-rs-core")]),e._v("/"),s("a",{attrs:{href:"third_party/wasmi"}},[e._v("wasmi")]),e._v(" and provide the "),s("a",{attrs:{href:"samplecode/wasmi"}},[e._v("wasmi code sample")]),e._v(". The sample code shows how to use the ported WebAssembly interpreter to passes all 70 cases in "),s("a",{attrs:{href:"https://github.com/WebAssembly/testsuite/tree/c538faa43217146f458b9bc2d4b704d0a4d80963",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebAssembly testsuite")]),e._v("! . We put the ported interpreter inside the SGX enclave and provide a well-defined enclave interface for passing WebAssembly codes as input and get its results in the untrusted world. With the ported WebAssembly interpreter, one can easily execute wasm codes and protect its data safely using Intel SGX and benefits from Rust's memory safety guarantees!")]),e._v(" "),s("p",[s("strong",[e._v("Private set intersection sample")]),e._v(" As a best use case of Intel SGX, we provide a sample solution of Private-Set-Intersection in "),s("a",{attrs:{href:"samplecode/psi"}},[e._v("psi")]),e._v(" code sample. It is derived from the remote attestation sample and can solve the two-party private-set-intersection problem perfectly and "),s("strong",[e._v("resists side-channel attacks")]),e._v("!")]),e._v(" "),s("p",[s("strong",[e._v("Moving to rust-stable")]),e._v(" From v1.0.0, rust-sgx-sdk is going to be more stable and prepared for production. So stable branch of Rust is the best choice for the future of rust-sgx-sdk. In this version, we support the most recent Rust stable toolchain (stable-2018-05-10) in "),s("a",{attrs:{href:"https://github.com/baidu/rust-sgx-sdk/tree/rust-stable",target:"_blank",rel:"noopener noreferrer"}},[e._v("rust-stable")]),e._v(" branch and we are not catching up with the most recent nightly build due to a series of changes and unfinished codes reside in libstd and only support nightly-2018-04-12 in the master. We "),s("strong",[e._v("strongly recommend")]),e._v(" using the "),s("a",{attrs:{href:"https://github.com/baidu/rust-sgx-sdk/tree/rust-stable",target:"_blank",rel:"noopener noreferrer"}},[e._v("rust-stable")]),e._v(" branch for better stability and production use.")]),e._v(" "),s("p",[s("strong",[e._v("Support Intel SGX SDK v2.1.3")])]),e._v(" "),s("p",[s("strong",[e._v("Updated all docker images")]),e._v(" All "),s("a",{attrs:{href:"https://hub.docker.com/r/baiduxlab/sgx-rust/",target:"_blank",rel:"noopener noreferrer"}},[e._v("sgx-rust")]),e._v("/"),s("a",{attrs:{href:"https://hub.docker.com/r/baiduxlab/sgx-rust-experimental/",target:"_blank",rel:"noopener noreferrer"}},[e._v("sgx-rust-experimental")]),e._v("/"),s("a",{attrs:{href:"https://hub.docker.com/r/baiduxlab/sgx-rust-stable/",target:"_blank",rel:"noopener noreferrer"}},[e._v("sgx-rust-stable")]),e._v(" are updated accordingly. If you met problems similar to "),s("a",{attrs:{href:"https://github.com/baidu/rust-sgx-sdk/issues/4",target:"_blank",rel:"noopener noreferrer"}},[e._v('"Docker pull failed with unauthorized: authentication required"')]),e._v(", please check your network or wait for the service to recover.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v0-9-8-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v0-9-8-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v0.9.8 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("New branch rust-stable")]),e._v(" We provide a new branch to support stable channel of Rust in a new branch 'rust-stable'. It contains modified libraries and a customized xargo. The customized cargo allows Rust stable to compile sysroot by demonstrating "),s("code",[e._v("RUSTC_BOOTSTRAP")]),e._v(" as a env var. We provide a new docker image "),s("code",[e._v("baiduxlab/sgx-rust-stable")]),e._v(" as long as its "),s("a",{attrs:{href:"dockerfile/rust-stable"}},[e._v("dockerfile")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("Support Intel SGX SDK v2.1.2")])]),e._v(" "),s("p",[s("strong",[e._v("Support Rust nightly 2018-03-16")])]),e._v(" "),s("p",[s("strong",[e._v("Provide APIs against spectre attack")]),e._v(" We provide "),s("code",[e._v("sgx_trts::{rsgx_lfence,rsgx_sfence,rsgx_mfence}")]),e._v(" to help developers stop speculative execution on demand. We urge SGX developers to look at Intel's latest development "),s("a",{attrs:{href:"https://software.intel.com/sites/default/files/managed/e1/ec/SGX_SDK_Developer_Guidance-CVE-2017-5753.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("guide")]),e._v(" and another "),s("a",{attrs:{href:"https://software.intel.com/sites/default/files/managed/e1/ec/180309_SGX_SDK_Developer_Guidance_Edger8r.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("guide")]),e._v(". To defend against spectre, developers "),s("strong",[e._v("must")]),e._v(" rewrite their enclaves according to the guidance from Intel. We show how to rewrite SGX enclave to defend against spectre in TLS client/server and local attestation code samples.")]),e._v(" "),s("p",[s("strong",[e._v("New API "),s("code",[e._v("rsgx_is_enclave_crashed")])]),e._v(" We provide "),s("code",[e._v("sgx_trts::rsgx_is_enclave_crashed")]),e._v(" corresponding to a new feature of Intel SGX SDK 2.1.2.")]),e._v(" "),s("p",[s("strong",[e._v("rust-protobuf")]),e._v(" We provide a ported "),s("a",{attrs:{href:"https://crates.io/crates/protobuf",target:"_blank",rel:"noopener noreferrer"}},[e._v("protobuf")]),e._v(" library for SGX enclave at "),s("a",{attrs:{href:"third_party/protobuf"}},[e._v("protobuf")]),e._v(". And we provide an example showing how to use it at "),s("a",{attrs:{href:"samplecode/protobuf"}},[e._v("protobuf code sample")]),e._v(". Attention: please install the rust-protobuf compiler by "),s("code",[e._v("cargo install protobuf --vers=1.4.4")]),e._v(" before build the sample project.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v0-9-7-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v0-9-7-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v0.9.7 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Provide "),s("code",[e._v("sgx_tstd::untrusted")]),e._v(" namespace")]),e._v(" v0.9.7 provides "),s("code",[e._v("sgx_tstd::untrusted::{fs,path,time}")]),e._v(" which are related to ocall functions. They are always enabled no matter "),s("code",[e._v("untrusted_fs")]),e._v(" or "),s("code",[e._v("untrusted_time")]),e._v(" feature is enabled or not. The major concern of providing such a namespace is that we want the developer to know they are invoking ocall related functions that brings "),s("strong",[e._v("untrusted data")]),e._v(" into the "),s("strong",[e._v("trusted")]),e._v(" execution engine. For the best security practice, explicitly importing from "),s("code",[e._v("sgx_tstd::untrusted")]),e._v(" is better than enabling feature in "),s("code",[e._v("Cargo.toml")]),e._v(". We stress that "),s("code",[e._v("untrusted_fs")]),e._v(" and "),s("code",[e._v("untrusted_time")]),e._v(" features are designed to be "),s("strong",[e._v("contingency plans")]),e._v(" and should only be enabled when porting a very complex Rust crate to a Rust-SGX enclave.")]),e._v(" "),s("p",[s("strong",[e._v("Rename feature "),s("code",[e._v("untrusted_net")]),e._v(" to "),s("code",[e._v("net")])]),e._v(" "),s("code",[e._v("net")]),e._v(" is well-known as untrusted and we believe "),s("code",[e._v("net")]),e._v(" is a better choice and similar to other features: such as "),s("code",[e._v("backtrace")]),e._v(" and "),s("code",[e._v("stdio")]),e._v(".")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v0-9-6-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v0-9-6-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v0.9.6 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Support latest Rust nightly build (nightly-2018-02-05-x86_64-unknown-linux-gnu)")])]),e._v(" "),s("p",[s("strong",[e._v("Security enhancement")]),e._v(" Added three features for "),s("code",[e._v("sgx_tstd")]),e._v(": "),s("code",[e._v("untrusted_fs")]),e._v(" "),s("code",[e._v("untrusted_time")]),e._v(" "),s("code",[e._v("untrusted_net")]),e._v(" to control the insecure ocall interface. By default, io-related features in "),s("code",[e._v("fs/time/net")]),e._v(" are "),s("strong",[e._v("DISABLED")]),e._v(". To enable them, please add feature declarations such as "),s("code",[e._v('features = ["untrusted_fs"]')]),e._v(" for sgx_tstd in "),s("code",[e._v("Cargo.toml")]),e._v(". All sample codes and third party libraries are updated accordingly. Note that data from unstrusted "),s("code",[e._v("fs/time")]),e._v(" are "),s("strong",[e._v("UNTRUSTED")]),e._v("and thus use them "),s("strong",[e._v("AT YOUR OWN RISK")]),e._v(". Data from "),s("code",[e._v("net")]),e._v(" are well-known as untrusted and need validation instinctively. We strongly recommend our TLS termination for network access, instead of using "),s("code",[e._v("net")]),e._v(" directly.")]),e._v(" "),s("p",[s("strong",[e._v("Refined sgxtime and support sgxcounter")]),e._v(" Moved the trusted time service to "),s("code",[e._v("sgx_tservice::sgxtime")]),e._v(" and implemented the monotonic counter in "),s("code",[e._v("sgx_tservice::sgxcounter")]),e._v(".")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v0-9-5-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v0-9-5-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v0.9.5 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Support latest Rust nightly build (nightly-2018-01-19-x86_64-unknown-linux-gnu)")])]),e._v(" "),s("p",[s("strong",[e._v("Xargo support")]),e._v(" Rust SGX SDK v0.9.5 provides "),s("code",[e._v("xargo")]),e._v(" support with a target "),s("code",[e._v("x86_64-unknown-linux-sgx")]),e._v(". To compile a crate using "),s("code",[e._v("xargo")]),e._v(", add a corresponding json config and make appropirate changes to the source code, then compile it with "),s("code",[e._v("xargo build -target x86_64-unknown-linux-sgx --release")]),e._v(". Porting is easier! Please refer to the ported "),s("RouterLink",{attrs:{to:"/teaclave-sgx-sdk/third_party/"}},[e._v("third-party libraries")]),e._v(" for more details.")],1),e._v(" "),s("p",[s("strong",[e._v("Network access support")]),e._v(" We port part of "),s("code",[e._v("std::net")]),e._v(" to "),s("code",[e._v("sgx_tstd::net")]),e._v(". Now "),s("code",[e._v("sgx_tstd::net")]),e._v(" supports most of socket functions by using 12 ocalls (defined in "),s("code",[e._v("edl/sgx_net.edl")]),e._v(").")]),e._v(" "),s("p",[s("strong",[e._v("Rustls, webpki and ring for TLS support")]),e._v(" We port the most famous TLS implementation "),s("a",{attrs:{href:"https://github.com/ctz/rustls",target:"_blank",rel:"noopener noreferrer"}},[e._v("rustls")]),e._v(", along with its dependnecy "),s("a",{attrs:{href:"https://github.com/briansmith/webpki",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpki")]),e._v(" and crypto library "),s("a",{attrs:{href:"https://github.com/briansmith/ring",target:"_blank",rel:"noopener noreferrer"}},[e._v("ring")]),e._v(" into Rust-SGX world. And we provide a pair of TLS client/server application code samples. Please reference to tls sample codes for detail.")]),e._v(" "),s("p",[s("strong",[e._v("File system access (sgx_tstd::fs and sgx_tstd::sgxfs) support")]),e._v(" We port part of "),s("code",[e._v("std::fs")]),e._v(" to "),s("code",[e._v("sgx_tstd::fs")]),e._v(" for normal linux files. Also, we provide "),s("code",[e._v("sgx_tstd::sgxfs")]),e._v(" to support Intel's "),s("code",[e._v("protected_fs")]),e._v(", an encrypted file access mechanism.")]),e._v(" "),s("p",[s("strong",[e._v("Time (sgx_tstd::time and sgx::tservice::SgxTime) support")]),e._v(" We port "),s("code",[e._v("std::time")]),e._v(" to "),s("code",[e._v("sgx_tstd::time")]),e._v(" and it provides untrusted local time. We implement "),s("code",[e._v("sgx::tservice::SgxTime")]),e._v(" for the Intel ME based trusted timestamp. To use "),s("code",[e._v("SgxTime")]),e._v(", the "),s("a",{attrs:{href:"https://software.intel.com/en-us/sgx-sdk/download",target:"_blank",rel:"noopener noreferrer"}},[e._v("iClsclient library")]),e._v(" and "),s("a",{attrs:{href:"https://github.com/intel/dynamic-application-loader-host-interface",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dynamic Application Loader (DAL) Host Interface (aka JHI)")]),e._v(" are required. Please reference to "),s("RouterLink",{attrs:{to:"/teaclave-sgx-sdk/documents/sgxtime.html"}},[e._v("sgxtime usage")]),e._v(" for detail.")],1),e._v(" "),s("p",[s("strong",[e._v("Environment variable operation (sgx_tstd::env) support")]),e._v(" We port part of "),s("code",[e._v("std::env")]),e._v(" to "),s("code",[e._v("sgx_tstd::env")]),e._v(" to support setting/getting environment variables.")]),e._v(" "),s("h2",{attrs:{id:"new-third-party-libraries"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-third-party-libraries"}},[e._v("#")]),e._v(" New third-party libraries")]),e._v(" "),s("p",[e._v("All of the third-party libraries could be compiled by "),s("code",[e._v("make")]),e._v(" or "),s("code",[e._v("XARGO_SGX=1 make")]),e._v(". In this release, we have the following new libraries ported.")]),e._v(" "),s("ol",[s("li",[e._v("bincode")]),e._v(" "),s("li",[e._v("dtoa")]),e._v(" "),s("li",[e._v("heapsize")]),e._v(" "),s("li",[e._v("itoa")]),e._v(" "),s("li",[e._v("linked-hash-map")]),e._v(" "),s("li",[e._v("log")]),e._v(" "),s("li",[e._v("ring")]),e._v(" "),s("li",[e._v("rust-base64")]),e._v(" "),s("li",[e._v("rust-serialize")]),e._v(" "),s("li",[e._v("rustls")]),e._v(" "),s("li",[e._v("safemem")]),e._v(" "),s("li",[e._v("sct")]),e._v(" "),s("li",[e._v("serde-rs")]),e._v(" "),s("li",[e._v("webpki")])]),e._v(" "),s("h2",{attrs:{id:"about-xargo-s-sysroot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#about-xargo-s-sysroot"}},[e._v("#")]),e._v(" About xargo's sysroot")]),e._v(" "),s("p",[s("code",[e._v("xargo")]),e._v(" would generate a "),s("em",[e._v("sysroot")]),e._v(", including all basic libraries. In the past, everytime a Rust-SGX project is compiled via "),s("code",[e._v("make")]),e._v(", the basic Rust-SGX runtime would be compiled. Now, if we use "),s("code",[e._v("xargo")]),e._v(" to compile ("),s("code",[e._v("XARGO_SGX=1 make")]),e._v("), only the "),s("strong",[e._v("first time")]),e._v(" xargo builds the sysroot and saves them in Rust's directory and the basic Rust-SGX libraries would be re-used later.")]),e._v(" "),s("p",[e._v("The current sysroot includes:")]),e._v(" "),s("ol",[s("li",[e._v("libcompiler_builtins")]),e._v(" "),s("li",[e._v("libcore")]),e._v(" "),s("li",[e._v("liblibc")]),e._v(" "),s("li",[e._v("libpanic_abort")]),e._v(" "),s("li",[e._v("libpanic_unwind")]),e._v(" "),s("li",[e._v("libsgx_alloc")]),e._v(" "),s("li",[e._v("libsgx_rand")]),e._v(" "),s("li",[e._v("libsgx_serialize")]),e._v(" "),s("li",[e._v("libsgx_tcrypto")]),e._v(" "),s("li",[e._v("libsgx_tdh")]),e._v(" "),s("li",[e._v("libsgx_tkey_exchange")]),e._v(" "),s("li",[e._v("libsgx_tprotected_fs")]),e._v(" "),s("li",[e._v("libsgx_trts")]),e._v(" "),s("li",[e._v("libsgx_tse")]),e._v(" "),s("li",[e._v("libsgx_tseal")]),e._v(" "),s("li",[e._v("libsgx_tservice")]),e._v(" "),s("li",[e._v("libsgx_tunittest")]),e._v(" "),s("li",[e._v("libstd")]),e._v(" "),s("li",[e._v("libstd_unicode")]),e._v(" "),s("li",[e._v("libunwind")])]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v0-9-1-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v0-9-1-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v0.9.1 Release Notes")]),e._v(" "),s("p",[s("strong",[e._v("Support Intel SGX SDK 2.0 for Linux")]),e._v(" Intel released Intel SGX SDK 2.0 for Linux recently and we upgraded Rust SGX SDK to support it.")]),e._v(" "),s("p",[s("strong",[e._v("Support latest Rust nightly build (nightly-2017-11-29-x86_64-unknown-linux-gnu)")]),e._v(" We upgraded "),s("code",[e._v("sgx_tstd")]),e._v(" to support the latest Rust nightly release. On Nov 9th, "),s("code",[e._v("librand")]),e._v(" had been removed from "),s("code",[e._v("libstd")]),e._v(" in this "),s("a",{attrs:{href:"https://github.com/rust-lang/rust/commit/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe",target:"_blank",rel:"noopener noreferrer"}},[e._v("commit")]),e._v(" and we did the same change on "),s("code",[e._v("sgx_tstd")]),e._v(" as well as some other minor changes.")]),e._v(" "),s("p",[s("strong",[e._v("Provide rusty-machine in Intel SGX")]),e._v(" We ported the most popular machine learning library "),s("a",{attrs:{href:"https://github.com/AtheMathmo/rusty-machine",target:"_blank",rel:"noopener noreferrer"}},[e._v("rusty-machine")]),e._v(" to Intel SGX, along with its examples. Please refer to the "),s("a",{attrs:{href:"https://github.com/baidu/rust-sgx-sdk/tree/master/third_party/rusty-machine",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rust SGX version rusty-machine")]),e._v(" and the machine learning code samples for more details.")]),e._v(" "),s("h1",{attrs:{id:"rust-sgx-sdk-v0-9-0-release-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-sgx-sdk-v0-9-0-release-notes"}},[e._v("#")]),e._v(" Rust SGX SDK v0.9.0 Release Notes")]),e._v(" "),s("p",[e._v("Almost there! Rust SGX SDK v0.9.0 is coming up as a beta version of the future v1.0.0, with the most desired "),s("code",[e._v("sgx_tstd")]),e._v(" as well as many new features!")]),e._v(" "),s("p",[s("strong",[e._v("Support Crate porting.")]),e._v(" Porting existing Rust crates into the SGX world becomes "),s("strong",[e._v("possible")]),e._v(". We have successfully ported several crates from Crates.io with little modifications. Please refer to the section 'Porting Rust Crates' for step-by-step instructions.")]),e._v(" "),s("p",[s("strong",[e._v("Support programming untrusted components in Rust.")]),e._v(" Now v0.9.0 provides "),s("code",[e._v("sgx_urts")]),e._v(" for the untrusted world! One can write Rust codes to start and run an SGX enclave!")]),e._v(" "),s("p",[s("strong",[e._v("Support Serialization/deserialization .")]),e._v(" Passing structured data to the enclave is no longer a problem! Rust SGX SDK v0.9.0 comes with "),s("code",[e._v("sgx_serialize")]),e._v(", providing secure serialization and deserialization APIs!")]),e._v(" "),s("p",[s("strong",[e._v("Support "),s("code",[e._v("stdin/stdout/stderr")]),e._v(".")]),e._v(" Now macros like "),s("code",[e._v("println!")]),e._v(" are available inside SGX enclave.")]),e._v(" "),s("p",[s("strong",[e._v("Support "),s("code",[e._v("backtrace")]),e._v(" inside SGX enclaves.")]),e._v(" Stack backtrace inside an SGX enclave could be automatically dumped on panicking after enabling the backtrace mechanism.")]),e._v(" "),s("p",[s("strong",[e._v("Support unit tests.")]),e._v(" Now one can write unit tests with Rust style assertions. Please refer to the new crate "),s("code",[e._v("sgx_tunittest")]),e._v(".")]),e._v(" "),s("p",[e._v("Rust SGX SDK v0.9.0 supports up-to-date Rust nightly build (tested on rust version 1.22.0-nightly (3c96d40d3 2017-09-28)).")]),e._v(" "),s("p",[e._v("Welcome to report bugs, and we will fix them as soon as possible. Thanks for your contributions!")]),e._v(" "),s("h2",{attrs:{id:"new-features"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-features"}},[e._v("#")]),e._v(" New Features")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("sgx_tstd")]),e._v(" (previously known as "),s("code",[e._v("sgx_tstdc")]),e._v(") is designed to act as "),s("code",[e._v("std")]),e._v(" in SGX programming. Now "),s("code",[e._v("sgx_tstd")]),e._v(" "),s("strong",[e._v("fully")]),e._v(" supports of "),s("code",[e._v("any")]),e._v(", "),s("code",[e._v("ascii")]),e._v(" "),s("code",[e._v("borrow")]),e._v(", "),s("code",[e._v("boxed")]),e._v(", "),s("code",[e._v("cell")]),e._v(", "),s("code",[e._v("char")]),e._v(", "),s("code",[e._v("clone")]),e._v(", "),s("code",[e._v("cmp")]),e._v(", "),s("code",[e._v("collections")]),e._v(", "),s("code",[e._v("convert")]),e._v(", "),s("code",[e._v("default")]),e._v(", "),s("code",[e._v("error")]),e._v(", "),s("code",[e._v("f32")]),e._v(", "),s("code",[e._v("f64")]),e._v(", "),s("code",[e._v("ffi")]),e._v(", "),s("code",[e._v("fmt")]),e._v(", "),s("code",[e._v("hash")]),e._v(", "),s("code",[e._v("i8")]),e._v(", "),s("code",[e._v("i16")]),e._v(", "),s("code",[e._v("i32")]),e._v(", "),s("code",[e._v("i64")]),e._v(", "),s("code",[e._v("io")]),e._v(", "),s("code",[e._v("isize")]),e._v(", "),s("code",[e._v("iter")]),e._v(", "),s("code",[e._v("marker")]),e._v(", "),s("code",[e._v("mem")]),e._v(", "),s("code",[e._v("num")]),e._v(", "),s("code",[e._v("ops")]),e._v(", "),s("code",[e._v("option")]),e._v(", "),s("code",[e._v("panic")]),e._v(", "),s("code",[e._v("prelude")]),e._v(", "),s("code",[e._v("ptr")]),e._v(", "),s("code",[e._v("rc")]),e._v(", "),s("code",[e._v("result")]),e._v(", "),s("code",[e._v("slice")]),e._v(", "),s("code",[e._v("str")]),e._v(", "),s("code",[e._v("string")]),e._v(", "),s("code",[e._v("u8")]),e._v(", "),s("code",[e._v("u16")]),e._v(", "),s("code",[e._v("u32")]),e._v(", "),s("code",[e._v("u64")]),e._v(", "),s("code",[e._v("usize")]),e._v(", "),s("code",[e._v("vec")]),e._v(", "),s("code",[e._v("heap")]),e._v(", "),s("code",[e._v("i128")]),e._v(", "),s("code",[e._v("intrinsics")]),e._v(", "),s("code",[e._v("raw")]),e._v(", "),s("code",[e._v("u128")]),e._v(", and "),s("strong",[e._v("partially")]),e._v(" supports of "),s("code",[e._v("fs")]),e._v(", "),s("code",[e._v("os")]),e._v(", "),s("code",[e._v("path")]),e._v(", "),s("code",[e._v("sync")]),e._v(" and "),s("code",[e._v("thread")]),e._v(". For details, please refer to the section 'Difference between "),s("code",[e._v("sgx_tstd")]),e._v(" and Rust "),s("code",[e._v("std")]),e._v("'.")]),e._v(" "),s("li",[e._v("New supports in untrusted world include "),s("code",[e._v("sgx_urts")]),e._v(" (e.g., untrusted run time), "),s("code",[e._v("sgx_ustdio")]),e._v(" (e.g., helper functions of stdio) and "),s("code",[e._v("sgx_ubacktrace")]),e._v(" (e.g., helper functions of backtrace).")]),e._v(" "),s("li",[e._v("Serialization/deserialization is supported by "),s("code",[e._v("sgx_serialzie")]),e._v(".")]),e._v(" "),s("li",[e._v("Rust style PRNG interface "),s("code",[e._v("sgx_rand")]),e._v(" along with its "),s("code",[e._v("Derive")]),e._v(" feature support.")]),e._v(" "),s("li",[e._v("Backtrace mechanism is provided by mod "),s("code",[e._v("backtrace")]),e._v(" in "),s("code",[e._v("sgx_tstd")]),e._v(" and "),s("code",[e._v("sgx_ubacktrace")]),e._v(" + "),s("code",[e._v("libbacktrace")]),e._v(".")]),e._v(" "),s("li",[e._v("Adopting the new "),s("code",[e._v("alloc_system")]),e._v(" through "),s("code",[e._v("sgx_alloc")]),e._v(".")])]),e._v(" "),s("h2",{attrs:{id:"new-sample-codes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-sample-codes"}},[e._v("#")]),e._v(" New sample codes")]),e._v(" "),s("p",[e._v("In "),s("code",[e._v("samplecode")]),e._v(" directory, we provide the following new code samples:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("hello-rust")]),e._v(" is the helloworld sample written in pure Rust.")]),e._v(" "),s("li",[s("code",[e._v("backtrace")]),e._v(" is a sample showing how to enabling backtrace mechanism inside the enclave.")]),e._v(" "),s("li",[s("code",[e._v("file")]),e._v(" shows basic usage of SGX's new file system APIs.")]),e._v(" "),s("li",[s("code",[e._v("unit-test")]),e._v(" shows the way of writing unit tests and conduct unit testing.")]),e._v(" "),s("li",[s("code",[e._v("zlib-lazy-static-sample")]),e._v(" shows how to use ported third party crates inside enclave.")])]),e._v(" "),s("p",[e._v("In "),s("code",[e._v("third_party")]),e._v(" directory, we provide six crates ported from untrusted world.")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("inflate")]),e._v(" a simple implementation of inflate algorithm.")]),e._v(" "),s("li",[s("code",[e._v("libflate")]),e._v(" a more complex implementation of inflate algorithm. It dependents on "),s("code",[e._v("adler32-rs")]),e._v(" and "),s("code",[e._v("byteorder")]),e._v(".")]),e._v(" "),s("li",[s("code",[e._v("lazy-static.rs")]),e._v(" a widely used crate for initializing static data structures.")]),e._v(" "),s("li",[s("code",[e._v("yansi")]),e._v(" printing colorful characters on terminal.")])]),e._v(" "),s("h2",{attrs:{id:"programming-with-sgx-tstd-in-enclave"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#programming-with-sgx-tstd-in-enclave"}},[e._v("#")]),e._v(" Programming with "),s("code",[e._v("sgx_tstd")]),e._v(" in enclave")]),e._v(" "),s("p",[s("code",[e._v("std")]),e._v(" is the most important and fundamental crate in Rust. Due to Intel SGX's limitations, many features in Rust's "),s("code",[e._v("std")]),e._v(" are incompatible with SGX, thus not all features of "),s("code",[e._v("std")]),e._v(" are available in Intel SGX enclaves.")]),e._v(" "),s("p",[e._v("To offer a user-friendly and secure Rust environment in SGX, we implement "),s("code",[e._v("sgx_tstd")]),e._v(". It is very much similar to Rust's "),s("code",[e._v("std")]),e._v(" and easy to use. Here is a sample usage:")]),e._v(" "),s("p",[e._v("In Cargo.toml of your project, add the following line to include "),s("code",[e._v("sgx_tstd")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('[dependency]\nsgx_tstd = { path = "path/to/sgx_tstd" }\n')])])]),s("p",[e._v("And add the following lines in your "),s("code",[e._v("lib.rs")]),e._v(" (use "),s("code",[e._v("vec")]),e._v(" as an example here):")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("extern crate sgx_tstd as std;\nuse std::vec::Vec;\n")])])]),s("p",[e._v("One can use "),s("code",[e._v("sgx_tstd")]),e._v(" in the namespace of "),s("code",[e._v("std")]),e._v(" and write Rust program as usual.")]),e._v(" "),s("p",[e._v("But "),s("code",[e._v("sgx_tstd")]),e._v(" has its own limitations. We replace some Rust struct with SGX struct (e.g. "),s("code",[e._v("Mutex")]),e._v(" now is "),s("code",[e._v("SgxMutex")]),e._v("). We rename some of these structs because the implementation of "),s("code",[e._v("SgxMutex")]),e._v(" is vastly different from Rust's "),s("code",[e._v("Mutex")]),e._v(". And we want developers to be clear which mutex they are using.")]),e._v(" "),s("p",[e._v("Please refer to 'Difference between "),s("code",[e._v("sgx_tstd")]),e._v(" and Rust "),s("code",[e._v("std")]),e._v("' for the detail of "),s("code",[e._v("sgx_tstd")]),e._v(".")]),e._v(" "),s("h2",{attrs:{id:"porting-rust-crates-into-the-sgx-world"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#porting-rust-crates-into-the-sgx-world"}},[e._v("#")]),e._v(" Porting Rust Crates into the SGX world")]),e._v(" "),s("p",[e._v("The most important thing is that the trusted world is a "),s("code",[e._v("no_std")]),e._v(" world. If you see linking errors such as "),s("code",[e._v("f32")]),e._v(" "),s("code",[e._v("f64")]),e._v(" "),s("code",[e._v("panic_fmt")]),e._v(" is already defined in "),s("code",[e._v("std")]),e._v(", it means that you are linking the Rust's "),s("code",[e._v("std")]),e._v(" to the enclave. This is absolutely "),s("strong",[e._v("wrong")]),e._v(". You need to check "),s("strong",[e._v("every direct and indirect dependent crates")]),e._v(" to see if depends on "),s("code",[e._v("std")]),e._v(".")]),e._v(" "),s("p",[e._v("Here is a step-by-step instruction for porting crates to the SGX enclave. To be easy, we name the crate you want to port as 'root crate'.")]),e._v(" "),s("ol",[s("li",[e._v("For each dependent crate of the root crate, check if it uses something like "),s("code",[e._v("std::vec::Vec")]),e._v(". Almost all crates use "),s("code",[e._v("std")]),e._v(".")]),e._v(" "),s("li",[e._v("Download the source codes of the above identified dependent crates.")]),e._v(" "),s("li",[e._v("Fix their "),s("code",[e._v("Cargo.toml")]),e._v(". In the dependency section, change the crate location to local file system ("),s("code",[e._v('{ path = "path/to/lib" }')]),e._v(")")]),e._v(" "),s("li",[e._v("Add "),s("code",[e._v("sgx_tstd")]),e._v(" to "),s("code",[e._v("Cargo.toml")]),e._v(" as a new dependency, e.g., "),s("code",[e._v('sgx_tstd = { path = "path/to/sgx_tstd" }')]),e._v(".")]),e._v(" "),s("li",[e._v("Edit the source code of each "),s("code",[e._v("lib.rs")]),e._v(". Add "),s("code",[e._v("#[no_std]")]),e._v(" at the beginning, after all "),s("code",[e._v("#![]")]),e._v(" inner attributes.")]),e._v(" "),s("li",[e._v("Add an extra statement: "),s("code",[e._v("extern crate sgx_tstd as std")]),e._v(" to include "),s("code",[e._v("sgx_tstd")]),e._v(" under the "),s("code",[e._v("std")]),e._v(" namespace.")]),e._v(" "),s("li",[e._v("Eliminate all of the references to unsupported mod/macro/feature of "),s("code",[e._v("sgx_tstd")]),e._v(".")]),e._v(" "),s("li",[e._v("Compile.")])]),e._v(" "),s("p",[e._v("Please look into "),s("code",[e._v("third_party")]),e._v(" directory for porting samples.")]),e._v(" "),s("h2",{attrs:{id:"experimental-new-docker-image"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#experimental-new-docker-image"}},[e._v("#")]),e._v(" Experimental new docker image")]),e._v(" "),s("p",[e._v("The latest Intel SGX SDK for linux v1.9 only supports protobuf v2. Protobuf v2 has a lot of known bugs and is out-of-date. We provide an experimental dev environment with the latest protobuf v3.4.1 and a patched Intel SGX SDK v1.9.")]),e._v(" "),s("p",[e._v("The docker image is on the docker hub now. Please use the following command to download it.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("docker pull baiduxlab/sgx-rust-experimental\n")])])]),s("h2",{attrs:{id:"misc-issues-and-hacks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#misc-issues-and-hacks"}},[e._v("#")]),e._v(" Misc issues and hacks")]),e._v(" "),s("ul",[s("li",[e._v("In Intel's SGX SDK, "),s("code",[e._v("$(SGX_SDK)/lib64/libsgx_tprotected_fs.a")]),e._v(" and "),s("code",[e._v("libsgx_uprotected_fs.a")]),e._v(" contains extra header files, which would probably cause linking problems. To resolve this, one should run the following commands to remove the header files:")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("ar d $(SGX_SDK)/lib64/libsgx_uprotected_fs.a sgx_tprotected_fs_u.h\nar d $(SGX_SDK)/lib64/libsgx_tprotected_fs.a sgx_tprotected_fs_t.h\n")])])]),s("p",[e._v("In the docker environment, these two static libraries have been properly patched.")]),e._v(" "),s("ul",[s("li",[e._v("Linking error on multiple "),s("code",[e._v("liblibc")]),e._v(". Crate "),s("code",[e._v("libc")]),e._v(" is not designed for "),s("code",[e._v("#![no_std]")]),e._v(" environment. Though it provides features for "),s("code",[e._v("no_std")]),e._v(", it cannot be linked to SGX enclaves. To resolve this, one should remove one of the existing "),s("code",[e._v("liblibc")]),e._v(" rlib. Based on our observations, the larger one is the correct one.")])]),e._v(" "),s("p",[e._v("In our docker environment, the extra "),s("code",[e._v("liblibc")]),e._v(" is removed.")]),e._v(" "),s("h2",{attrs:{id:"difference-between-sgx-tstd-and-rust-std"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#difference-between-sgx-tstd-and-rust-std"}},[e._v("#")]),e._v(" Difference between "),s("code",[e._v("sgx_tstd")]),e._v(" and Rust "),s("code",[e._v("std")])]),e._v(" "),s("p",[e._v("For now we support a subset of Rust's "),s("code",[e._v("std")]),e._v(" in the trusted world. There is a full list of supported mods/macros in "),s("code",[e._v("sgx_tstd")])]),e._v(" "),s("h3",{attrs:{id:"new-stuffs-in-sgx-tstd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-stuffs-in-sgx-tstd"}},[e._v("#")]),e._v(" New stuffs in "),s("code",[e._v("sgx_tstd")])]),e._v(" "),s("p",[e._v("New mods in "),s("code",[e._v("sgx_tstd")]),e._v(" : "),s("code",[e._v("enclave")]),e._v(", "),s("code",[e._v("backtrace")]),e._v(", "),s("code",[e._v("cpuid")]),e._v(" and "),s("code",[e._v("sync::spinlock")]),e._v(".")]),e._v(" "),s("p",[e._v("New macros : "),s("code",[e._v("global_ctors_object")]),e._v(" and "),s("code",[e._v("cfg_if")]),e._v(".")]),e._v(" "),s("p",[e._v("New SGX structures (corresponding to Rust's std) :")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Exist Structs")]),e._v(" "),s("th",[e._v("Rust Sgx Structs")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[s("code",[e._v("std::fs::File")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::fs::SgxFile")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::thread::Thread")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::thread::SgxThread")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::thread::ThreadId")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::thread::SgxThreadId")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::sync::Mutex")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::sync::SgxMutex")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::sync::MutexGuard")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::sync::SgxMutexGuard")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::sync::Condvar")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::sync::SgxCondvar")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::sync::RwLock")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::sync::SgxRwLock")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::sync::RwLockReadGuard")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::sync::SgxRwLockReadGuard")])])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("std::sync::RwLockwriteGuard")])]),e._v(" "),s("td",[s("code",[e._v("sgx_tstd::sync::SgxRwLockwriteGuard")])])])])]),e._v(" "),s("h3",{attrs:{id:"fully-supported-mods-in-sgx-tstd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fully-supported-mods-in-sgx-tstd"}},[e._v("#")]),e._v(" Fully supported mods in "),s("code",[e._v("sgx_tstd")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Mod")]),e._v(" "),s("th",[e._v("Description")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("any")]),e._v(" "),s("td",[e._v("This module implements the "),s("code",[e._v("Any")]),e._v(" trait.")])]),e._v(" "),s("tr",[s("td",[e._v("ascii")]),e._v(" "),s("td",[e._v("Operations on ASCII strings and characters.")])]),e._v(" "),s("tr",[s("td",[e._v("borrow")]),e._v(" "),s("td",[e._v("A module for working with borrowed data.")])]),e._v(" "),s("tr",[s("td",[e._v("boxed")]),e._v(" "),s("td",[e._v("A pointer type for heap allocation.")])]),e._v(" "),s("tr",[s("td",[e._v("cell")]),e._v(" "),s("td",[e._v("Shareable mutable containers.")])]),e._v(" "),s("tr",[s("td",[e._v("char")]),e._v(" "),s("td",[e._v("A character type.")])]),e._v(" "),s("tr",[s("td",[e._v("clone")]),e._v(" "),s("td",[e._v("The clone trait for types that cannot be 'implicitly copied'.")])]),e._v(" "),s("tr",[s("td",[e._v("cmp")]),e._v(" "),s("td",[e._v("Functionality for ordering and comparison.")])]),e._v(" "),s("tr",[s("td",[e._v("collections")]),e._v(" "),s("td",[e._v("Collection types.")])]),e._v(" "),s("tr",[s("td",[e._v("convert")]),e._v(" "),s("td",[e._v("Traits for conversions between types.")])]),e._v(" "),s("tr",[s("td",[e._v("default")]),e._v(" "),s("td",[e._v("The default trait for types which may have meaningful default values.")])]),e._v(" "),s("tr",[s("td",[e._v("error")]),e._v(" "),s("td",[e._v("Trais for working with Errors.")])]),e._v(" "),s("tr",[s("td",[e._v("f32")]),e._v(" "),s("td",[e._v("32 bit float point support.")])]),e._v(" "),s("tr",[s("td",[e._v("f64")]),e._v(" "),s("td",[e._v("64 bit float point support.")])]),e._v(" "),s("tr",[s("td",[e._v("ffi")]),e._v(" "),s("td",[e._v("Utilities related to FFI bindings.")])]),e._v(" "),s("tr",[s("td",[e._v("fmt")]),e._v(" "),s("td",[e._v("Utilities for formatting and printing Strings.")])]),e._v(" "),s("tr",[s("td",[e._v("hash")]),e._v(" "),s("td",[e._v("Generic hashing support.")])]),e._v(" "),s("tr",[s("td",[e._v("i8")]),e._v(" "),s("td",[e._v("The 8-bit signed integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("i16")]),e._v(" "),s("td",[e._v("The 6-bit signed integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("i32")]),e._v(" "),s("td",[e._v("The 32-bit signed integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("i64")]),e._v(" "),s("td",[e._v("The 64-bit signed integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("io")]),e._v(" "),s("td",[e._v("Traits, helpers, and type definitions for core I/O functionality.")])]),e._v(" "),s("tr",[s("td",[e._v("isize")]),e._v(" "),s("td",[e._v("The pointer-sized signed integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("iter")]),e._v(" "),s("td",[e._v("Composable external iteration.")])]),e._v(" "),s("tr",[s("td",[e._v("marker")]),e._v(" "),s("td",[e._v("Primitive traits and types representing basic properties of types.")])]),e._v(" "),s("tr",[s("td",[e._v("mem")]),e._v(" "),s("td",[e._v("Basic functions for dealing with memory.")])]),e._v(" "),s("tr",[s("td",[e._v("num")]),e._v(" "),s("td",[e._v("Additional functionality for numeric.")])]),e._v(" "),s("tr",[s("td",[e._v("ops")]),e._v(" "),s("td",[e._v("Overloadable operators.")])]),e._v(" "),s("tr",[s("td",[e._v("option")]),e._v(" "),s("td",[e._v("Optional values.")])]),e._v(" "),s("tr",[s("td",[e._v("panic")]),e._v(" "),s("td",[e._v("Panic support in the standard library.")])]),e._v(" "),s("tr",[s("td",[e._v("prelude")]),e._v(" "),s("td",[e._v("The Rust Prelude.")])]),e._v(" "),s("tr",[s("td",[e._v("ptr")]),e._v(" "),s("td",[e._v("Raw, unsafe pointers, "),s("code",[e._v("*const T")]),e._v(", and "),s("code",[e._v("*mut T")]),e._v(".")])]),e._v(" "),s("tr",[s("td",[e._v("rc")]),e._v(" "),s("td",[e._v("Single-threaded reference-counting pointers. ’Rc’ stands for ‘Reference Counted’")])]),e._v(" "),s("tr",[s("td",[e._v("result")]),e._v(" "),s("td",[e._v("Error handling with the Result type.")])]),e._v(" "),s("tr",[s("td",[e._v("slice")]),e._v(" "),s("td",[e._v("A dynamically-sized view into a contiguous sequence, "),s("code",[e._v("[T]")]),e._v(".")])]),e._v(" "),s("tr",[s("td",[e._v("str")]),e._v(" "),s("td",[e._v("Unicode string slices.")])]),e._v(" "),s("tr",[s("td",[e._v("string")]),e._v(" "),s("td",[e._v("A UTF-8 encoded, growable string.")])]),e._v(" "),s("tr",[s("td",[e._v("u8")]),e._v(" "),s("td",[e._v("The 8-bit unsigned integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("u16")]),e._v(" "),s("td",[e._v("The 16-bit unsigned integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("u32")]),e._v(" "),s("td",[e._v("The 32-bit unsigned integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("u64")]),e._v(" "),s("td",[e._v("The 64-bit unsigned integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("usize")]),e._v(" "),s("td",[e._v("The pointer-sized unsigned integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("vec")]),e._v(" "),s("td",[e._v("A contiguous growable array type with heap-allocated content, written "),s("code",[e._v("Vec<T>")]),e._v(".")])]),e._v(" "),s("tr",[s("td",[e._v("heap")]),e._v(" "),s("td",[e._v("dox")])]),e._v(" "),s("tr",[s("td",[e._v("i128")]),e._v(" "),s("td",[e._v("The 128-bit signed integer type.")])]),e._v(" "),s("tr",[s("td",[e._v("intrinsics")]),e._v(" "),s("td",[e._v("Rustc compiler intrinsics.")])]),e._v(" "),s("tr",[s("td",[e._v("raw")]),e._v(" "),s("td",[e._v("Contains struct definitions for the layout of compiler built-in types.")])]),e._v(" "),s("tr",[s("td",[e._v("u128")]),e._v(" "),s("td",[e._v("The 128-bit unsigned integer type.")])])])]),e._v(" "),s("h3",{attrs:{id:"fully-supported-macros-in-sgx-tstd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fully-supported-macros-in-sgx-tstd"}},[e._v("#")]),e._v(" Fully supported macros in "),s("code",[e._v("sgx_tstd")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Macros")]),e._v(" "),s("th",[e._v("Description")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("assert")]),e._v(" "),s("td",[e._v("Ensure that a boolean expression is true at runtime.")])]),e._v(" "),s("tr",[s("td",[e._v("assert_eq")]),e._v(" "),s("td",[e._v("Asserts that two expressions are equal to each other (using PartialEq).")])]),e._v(" "),s("tr",[s("td",[e._v("assert_ne")]),e._v(" "),s("td",[e._v("Asserts that two expressions are not equal to each other (using PartialEq).")])]),e._v(" "),s("tr",[s("td",[e._v("cfg")]),e._v(" "),s("td",[e._v("Boolean evaluation of configuration flags.")])]),e._v(" "),s("tr",[s("td",[e._v("column")]),e._v(" "),s("td",[e._v("A macro which expands to the column number on which it was invoked.")])]),e._v(" "),s("tr",[s("td",[e._v("compile_error")]),e._v(" "),s("td",[e._v("Unconditionally causes compilation to fail with the given error message when encountered.")])]),e._v(" "),s("tr",[s("td",[e._v("concat")]),e._v(" "),s("td",[e._v("Concatenates literals into a static string slice.")])]),e._v(" "),s("tr",[s("td",[e._v("debug_assert")]),e._v(" "),s("td",[e._v("Ensure that a boolean expression is true at runtime.")])]),e._v(" "),s("tr",[s("td",[e._v("debug_assert_eq")]),e._v(" "),s("td",[e._v("Asserts that two expressions are equal to each other.")])]),e._v(" "),s("tr",[s("td",[e._v("debug_assert_ne")]),e._v(" "),s("td",[e._v("Asserts that two expressions are not equal to each other.")])]),e._v(" "),s("tr",[s("td",[e._v("env")]),e._v(" "),s("td",[e._v("Inspect an environment variable at compile time.")])]),e._v(" "),s("tr",[s("td",[e._v("eprint")]),e._v(" "),s("td",[e._v("Macro for printing to the standard error.")])]),e._v(" "),s("tr",[s("td",[e._v("eprintln")]),e._v(" "),s("td",[e._v('"Macro for printing to the standard error with a newline."')])]),e._v(" "),s("tr",[s("td",[e._v("file")]),e._v(" "),s("td",[e._v("A macro which expands to the file name from which it was invoked.")])]),e._v(" "),s("tr",[s("td",[e._v("format")]),e._v(" "),s("td",[e._v("Use the syntax described in std::fmt to create a value of type string. See std::fmt for more information.")])]),e._v(" "),s("tr",[s("td",[e._v("format_arg")]),e._v(" "),s("td",[e._v("The core macro for formatted string creation & output.")])]),e._v(" "),s("tr",[s("td",[e._v("include")]),e._v(" "),s("td",[e._v("Parse a file as an expression or an item according to the context.")])]),e._v(" "),s("tr",[s("td",[e._v("include_bytes")]),e._v(" "),s("td",[e._v("Includes a file as a reference to a byte array.")])]),e._v(" "),s("tr",[s("td",[e._v("include_str")]),e._v(" "),s("td",[e._v("Includes a utf8-encoded file as a string.")])]),e._v(" "),s("tr",[s("td",[e._v("line")]),e._v(" "),s("td",[e._v("A macro which expands to the line number on which it was invoked.")])]),e._v(" "),s("tr",[s("td",[e._v("module_path")]),e._v(" "),s("td",[e._v("Expands to a string that represents the current module path.")])]),e._v(" "),s("tr",[s("td",[e._v("option_env")]),e._v(" "),s("td",[e._v("Optionally inspect an environment variable at compile time.")])]),e._v(" "),s("tr",[s("td",[e._v("panic")]),e._v(" "),s("td",[e._v("The entry point for panic of Rust threads.")])]),e._v(" "),s("tr",[s("td",[e._v("print")]),e._v(" "),s("td",[e._v("Macro for printing to the standard output.")])]),e._v(" "),s("tr",[s("td",[e._v("println")]),e._v(" "),s("td",[e._v("Macro for printing to the standard output with a newline.")])]),e._v(" "),s("tr",[s("td",[e._v("stringify")]),e._v(" "),s("td",[e._v("A macro which stringifies its argument.")])]),e._v(" "),s("tr",[s("td",[e._v("thread_local")]),e._v(" "),s("td",[e._v("Declare a new thread local storage key of type std::thread::LocalKey.")])]),e._v(" "),s("tr",[s("td",[e._v("concat_idents")]),e._v(" "),s("td",[e._v("Concatenate identifiers into one identifier.")])]),e._v(" "),s("tr",[s("td",[e._v("try")]),e._v(" "),s("td",[e._v("Helper macro for reducing boilerplate code for matching Result together with converting downstream errors.")])]),e._v(" "),s("tr",[s("td",[e._v("unimplemented")]),e._v(" "),s("td",[e._v("A standardized placeholder for marking unfinished code. It panics with the message “not yet implemented” when executed.")])]),e._v(" "),s("tr",[s("td",[e._v("unreachable")]),e._v(" "),s("td",[e._v("A utility macro for indicating unreachable code.")])]),e._v(" "),s("tr",[s("td",[e._v("vec")]),e._v(" "),s("td",[e._v("Creates a Vec containing the arguments.")])]),e._v(" "),s("tr",[s("td",[e._v("write")]),e._v(" "),s("td",[e._v("Write formatted data into a buffer.")])]),e._v(" "),s("tr",[s("td",[e._v("writeln")]),e._v(" "),s("td",[e._v("Write formatted data into a buffer, with a newline appended.")])])])]),e._v(" "),s("h3",{attrs:{id:"partially-supported-mods-traits-in-sgx-tstd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#partially-supported-mods-traits-in-sgx-tstd"}},[e._v("#")]),e._v(" Partially supported mods/traits in "),s("code",[e._v("sgx_tstd")])]),e._v(" "),s("p",[s("code",[e._v("std::fs")]),e._v(", "),s("code",[e._v("std::os")]),e._v(", "),s("code",[e._v("std::path")]),e._v(", "),s("code",[e._v("std::sync")]),e._v(", "),s("code",[e._v("std::thread")]),e._v(" are partially supported in "),s("code",[e._v("sgx_tstd")]),e._v(". Here we only list the unsupported parts of them. All the other parts are supported.")]),e._v(" "),s("ol",[s("li",[s("p",[s("code",[e._v("std::fs")]),e._v("\nUnsupported stuffs:\n"),s("code",[e._v("fs::Dirbuilder; fs::DirEntry; fs::FileType; fs::Metadata; fs::Permissions; fs::ReadDir; fs::canonicalize; fs::create_dir; fs::create_dir_all; fs::hard_link; fs::metadata; fs::read_dir; fs::read_link; fs::remove_dir; fs::remove_dir_all; fs::rename; fs::set_permissions; fs::soft_link; fs::symlink_metadata; fs::File::sync_all; fs::File::sync_data; fs::File::set_len; fs::File::metadata; fs::File::try_clone; fs::File::set_permissions; Debug for fs::File; AsRawFd for fs::File; FromRawFd for fs::File; IntoRawFd for fs::File; FileEx for fs::File; Clone for fs::OpenOptions; Debug for fs::OpenOptions; OpenOptionsExt for fs::OpenOptions;")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("std::os")]),e._v("\nUnsupported stuffs:\n"),s("code",[e._v("os::linux; os::raw; os::unix::io; os::unix::net; os::unix::process; os::unix::raw; os::unix::thead; os::unix::fs::DirBuilderExt; os::unix::fs::DirEntryExt; os::unix::fs::FileTypeExt; os::unix::fs::MetadataExt; os::unix::fs::OpenOptionsExt; os::unix::fs::PermissionsExt;")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("std::path")]),e._v("\nUnsupported stuffs:\n"),s("code",[e._v("path::Path::maetadata; path::Path::symlink_metadat; path::Path::canonicalize; path::Path::read_link; path::Path::read_dir; path::Path::exists; path::Path::is_file; path::Path::is_dir;")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("std::sync")]),e._v("\nUnsupported stuffs:\n"),s("code",[e._v("sync::mpsc; sync::WaitTimeoutResult; sync::Condvar::wait_timeout_ms; sync::Condvar::wait_timeout;")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("std::thread")]),e._v("\nUnsupported stuffs:\n"),s("code",[e._v("thread::Builder; thread::JoinHandle; thread::park_timeout; thread::park_timeout_ms; thread::sleep; thread::sleep_ms; thread::spawn; thread::yield_now; thread::Result; thread::Thread::name; Debug for thread::Thread;")])])])]),e._v(" "),s("h3",{attrs:{id:"unsupported-stuffs-in-sgx-tstd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unsupported-stuffs-in-sgx-tstd"}},[e._v("#")]),e._v(" Unsupported stuffs in "),s("code",[e._v("sgx_tstd")])]),e._v(" "),s("p",[e._v("Mod : "),s("code",[e._v("std::env")]),e._v(", "),s("code",[e._v("std::net")]),e._v(", "),s("code",[e._v("std::process")]),e._v(", "),s("code",[e._v("std::time")]),e._v("\nMacro : "),s("code",[e._v("select")])])])}),[],!1,null,null,null);t.default=o.exports}}]);